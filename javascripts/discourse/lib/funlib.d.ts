// Generated by dts-bundle-generator v9.5.1

export interface SvgOptions {
	title?: string;
	lineWidth?: number;
	midBorderX?: number;
	midBorderY?: number;
	outerBorder?: number;
	bgOpacity?: number;
	headerOpacity?: number;
	mergeLimit?: number;
	axisCells?: number;
	normalize?: boolean;
	scriptSpacing?: number;
	width?: number;
	font?: string;
}
export declare const B: unique symbol;
export interface B<Brand> {
	[B]?: Brand;
}
export type axisPairs = [
	[
		"L0",
		"stroke"
	],
	[
		"L1",
		"surge"
	],
	[
		"L2",
		"sway"
	],
	[
		"R0",
		"twist"
	],
	[
		"R1",
		"roll"
	],
	[
		"R2",
		"pitch"
	],
	[
		"A1",
		"suck"
	]
];
export type mantissa = number & B<[
	any,
	"mantissa"
]>;
export type mantissaText = string & B<[
	any,
	"mantissa"
]>;
export type ms = number & B<[
	"time",
	"ms"
]>;
export type seconds = number & B<[
	"time",
	"s"
]>;
export type timeSpan = string & B<[
	"time",
	"TimeSpan"
]>;
export type speed = number & B<[
	"speed",
	"u/s"
]>;
export type speed10 = number & B<[
	"speed",
	"0.1u/s"
]>;
/** @deprecated use pos instead */
export type axisValue = number & B<[
	"axis",
	"u"
]>;
export type axisNorm = number & B<[
	"axis",
	"mantissa"
]>;
export type axisAngle = number & B<[
	"axis",
	"deg"
]>;
export type axisRaw = number & B<[
	"axis",
	"deg" | "mantissa"
]>;
export type axis = `${"L" | "R" | "A"}${0 | 1 | 2}` & B<[
	"axis",
	"name"
]>;
export type axisName = axisPairs[number][1];
export type axisLike = axis | axisName;
export type AxisToName = {
	[K in axisPairs[number] as K[0]]: K[1];
} & {
	[K in axisPairs[number] as K[1]]: K[0];
};
export type chapterName = string & B<[
	"chapter",
	"name"
]>;
export type TCodeTuple = [
	axis: axis,
	pos: pos
] | [
	axis: axis,
	pos: pos,
	"I",
	interval: ms
] | [
	axis: axis,
	pos: pos,
	"S",
	speed: speed
];
export type pos = axisValue;
export type at = ms;
export interface JsonAction {
	at: ms;
	pos: pos;
}
export interface JsonChapter {
	name: chapterName;
	startTime: timeSpan;
	endTime: timeSpan;
}
export interface JsonMetadata {
	bookmarks?: {
		name: string;
		time: timeSpan;
	}[];
	chapters?: JsonChapter[];
	duration?: seconds;
	title?: string;
}
export interface JsonFunscript {
	id?: axis;
	actions: JsonAction[];
	axes?: {
		id: axis;
		actions: JsonAction[];
	}[];
	metadata?: JsonMetadata;
}
declare function formatJson(json: string, { lineLength, maxPrecision, compress }?: {
	lineLength?: number;
	maxPrecision?: number;
	compress?: boolean;
}): string;
export declare function speedToOklch(speed: speed, useAlpha?: boolean): number[];
declare const TCodeAction_base: (new (...a: any[]) => readonly [
	axis: axis,
	pos: pos,
	type?: "I" | "S",
	target?: ms | speed
]);
declare class TCodeAction extends TCodeAction_base {
	static from(a: TCodeTuple | [
		TCodeTuple
	]): TCodeAction;
	constructor(...a: TCodeTuple | [
		TCodeTuple
	]);
	toString(ops?: {
		precision?: number;
		format?: boolean;
	}): string;
}
declare class TCodeList extends Array<TCodeAction> {
	static from(arrayLike: TCodeTuple[]): TCodeList;
	toString(ops?: {
		precision?: number;
		format?: boolean;
	}): string;
}
/**
 * Handy has a max speed and a min interval between actions
 * This function will smooth the actions to fit those constraints
 */
export declare function handySmooth(actions: FunAction[]): FunAction[];
export declare class FunAction implements JsonAction {
	#private;
	static linkList(list: FunAction[], extras: {
		parent?: Funscript | true;
	}): FunAction[];
	at: ms;
	pos: pos;
	constructor(action?: JsonAction, extras?: {
		parent?: Funscript;
	});
	get nextAction(): FunAction | undefined;
	get prevAction(): FunAction | undefined;
	get parent(): Funscript | undefined;
	/** speed from prev to this */
	get speedTo(): speed;
	/** speed from this to next */
	get speedFrom(): speed;
	get isPeak(): -1 | 0 | 1;
	/** Time difference to next action in milliseconds */
	get datNext(): ms;
	get datPrev(): ms;
	get dposNext(): pos;
	get dposPrev(): pos;
	clerpAt(at: ms): pos;
	static jsonOrder: {
		at: undefined;
		pos: undefined;
	};
	static cloneList(list: JsonAction[], extras: {
		parent?: Funscript | true;
	}): FunAction[];
	toJSON(): Record<string, any>;
	clone(): FunAction;
}
export declare class FunChapter implements JsonChapter {
	name: chapterName;
	startTime: timeSpan;
	endTime: timeSpan;
	constructor(chapter?: JsonChapter);
	get startAt(): ms;
	set startAt(v: ms);
	get endAt(): ms;
	set endAt(v: ms);
	static jsonOrder: {
		startTime: undefined;
		endTime: undefined;
		name: undefined;
	};
	toJSON(): Record<string, any>;
}
export declare class FunBookmark {
	name: string;
	time: timeSpan;
	constructor(bookmark?: {
		name: string;
		time: timeSpan;
	});
	get startAt(): ms;
	set startAt(v: ms);
	static jsonOrder: {
		time: undefined;
		name: undefined;
	};
	toJSON(): Record<string, any>;
}
export declare class FunMetadata implements JsonMetadata {
	duration: seconds;
	chapters: FunChapter[];
	bookmarks: FunBookmark[];
	constructor(metadata?: JsonMetadata, parent?: Funscript);
	static emptyJson: {
		bookmarks: never[];
		chapters: never[];
		creator: string;
		description: string;
		license: string;
		notes: string;
		performers: never[];
		script_url: string;
		tags: never[];
		title: string;
		type: string;
		video_url: string;
	};
	static jsonOrder: {
		title: undefined;
		creator: undefined;
		description: undefined;
		duration: undefined;
		chapters: undefined;
		bookmarks: undefined;
	};
	toJSON(): Record<string, any>;
	clone(): FunMetadata;
}
export declare class FunscriptFile {
	axisName: axisLike;
	title: string;
	dir: string;
	mergedFiles?: FunscriptFile[];
	constructor(filePath: string);
	get id(): axis | undefined;
	get filePath(): string;
	clone(): FunscriptFile;
}
export declare class Funscript implements JsonFunscript {
	#private;
	static svgDefaultOptions: Required<SvgOptions>;
	static toSvgElement(scripts: Funscript[], ops: SvgOptions): string;
	/** merge multi-axis scripts into one */
	static mergeMultiAxis(scripts: Funscript[]): Funscript[];
	id: axis;
	actions: FunAction[];
	axes: AxisScript[];
	metadata: FunMetadata;
	constructor(funscript?: JsonFunscript, extras?: {
		id?: axis;
		file?: string;
		axes?: JsonFunscript[];
		parent?: Funscript;
	});
	get parent(): Funscript | undefined;
	set parent(v: Funscript | undefined);
	get file(): FunscriptFile | undefined;
	get duration(): seconds;
	get actionsDuraction(): seconds;
	get actualDuration(): seconds;
	toStats(): {
		Duration: string;
		Actions: number;
		MaxSpeed: number;
		AvgSpeed: number;
	};
	toSvgElement(ops?: SvgOptions): string;
	normalize(): this;
	getAxes(): Funscript[];
	/** find an action after the given time */
	getActionAfter(at: ms): FunAction;
	getPosAt(at: ms): pos;
	getAxesPosAt(at: ms): {
		[k: string]: axisValue;
	};
	/** Returns TCode at the given time */
	getTCodeAt(at: ms): TCodeList;
	/** returns TCode to move from the current point to the next point on every axis */
	getTCodeFrom(at: ms, since?: ms): TCodeList;
	static emptyJson: {
		axes: never[];
		metadata: {};
		inverted: boolean;
		range: number;
		version: string;
	};
	static jsonOrder: {
		id: undefined;
		metadata: undefined;
		actions: undefined;
		axes: undefined;
	};
	toJSON(): Record<string, any>;
	toJsonText(options?: Parameters<typeof formatJson>[1]): string;
	clone(): Funscript;
}
export declare class AxisScript extends Funscript {
	id: axis;
	axes: [
	];
	constructor(funscript?: JsonFunscript, extras?: {
		id?: axis;
		filePath?: string;
		axes?: JsonFunscript[];
		parent?: Funscript;
	});
}

export {};
